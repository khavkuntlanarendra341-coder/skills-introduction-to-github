<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Particle Hand Tracker</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #canvas-container { position: relative; width: 100vw; height: 100vh; }
        video { display: none; } /* Hide the raw webcam feed */
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Hand Particle Controller</h1>
        <p>Open Hand: Saturn | Fist: Heart | Move Hand: Rotate/Color</p>
        <p id="status">Loading MediaPipe...</p>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry;
        const particleCount = 10000;
        let targetPositions = new Float32Array(particleCount * 3);
        let currentPositions = new Float32Array(particleCount * 3);
        let colors = new Float32Array(particleCount * 3);

        // --- 1. SHAPE GENERATORS ---
        const shapes = {
            sphere: () => {
                const data = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / particleCount);
                    const theta = Math.sqrt(particleCount * Math.PI) * phi;
                    data[i * 3] = 3 * Math.cos(theta) * Math.sin(phi);
                    data[i * 3 + 1] = 3 * Math.sin(theta) * Math.sin(phi);
                    data[i * 3 + 2] = 3 * Math.cos(phi);
                }
                return data;
            },
            heart: () => {
                const data = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const t = Math.random() * Math.PI * 2;
                    // Parametric Heart Formula
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    data[i * 3] = x * 0.2;
                    data[i * 3 + 1] = y * 0.2;
                    data[i * 3 + 2] = (Math.random() - 0.5) * 2;
                }
                return data;
            },
            saturn: () => {
                const data = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    if (i < particleCount * 0.4) { // The Planet
                        const phi = Math.random() * Math.PI * 2;
                        const theta = Math.random() * Math.PI;
                        data[i * 3] = 2 * Math.cos(phi) * Math.sin(theta);
                        data[i * 3 + 1] = 2 * Math.sin(phi) * Math.sin(theta);
                        data[i * 3 + 2] = 2 * Math.cos(theta);
                    } else { // The Rings
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 3 + Math.random() * 2;
                        data[i * 3] = Math.cos(angle) * radius;
                        data[i * 3 + 1] = Math.sin(angle) * radius * 0.2; // Flattened
                        data[i * 3 + 2] = Math.sin(angle) * radius;
                    }
                }
                return data;
            }
        };

        // --- 2. THREE.JS INITIALIZATION ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const startPos = shapes.sphere();
            targetPositions.set(startPos);
            currentPositions.set(startPos);

            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            
            const pMaterial = new THREE.PointsMaterial({
                size: 0.04,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            // Initial Colors
            for (let i = 0; i < particleCount * 3; i++) colors[i] = Math.random();
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            particles = new THREE.Points(geometry, pMaterial);
            scene.add(particles);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 3. MEDIAPIPE HAND TRACKING ---
        function initTracking() {
            const video = document.createElement('video');
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                document.getElementById('status').innerText = "Tracking Active";
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const hand = results.multiHandLandmarks[0];
                    
                    // Interaction 1: Rotate based on hand position
                    particles.rotation.y = (hand[0].x - 0.5) * 4;
                    particles.rotation.x = (hand[0].y - 0.5) * 4;

                    // Interaction 2: Morphing Logic
                    // Calculate "openness" by distance between thumb and pinky
                    const dx = hand[4].x - hand[20].x;
                    const dy = hand[4].y - hand[20].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist > 0.4) {
                        targetPositions.set(shapes.saturn());
                    } else if (dist < 0.15) {
                        targetPositions.set(shapes.heart());
                    } else {
                        targetPositions.set(shapes.sphere());
                    }
                }
            });

            const cameraPipe = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            cameraPipe.start();
        }

        // --- 4. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = geometry.attributes.position;
            for (let i = 0; i < particleCount * 3; i++) {
                // Smooth Lerp (Linear Interpolation)
                currentPositions[i] += (targetPositions[i] - currentPositions[i]) * 0.1;
            }
            posAttr.needsUpdate = true;

            renderer.render(scene, camera);
        }

        initThree();
        initTracking();
        animate();
    </script>
</body>
</html>